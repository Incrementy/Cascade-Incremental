<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cascade Incremental</title>
  <style>
    :root {
      --bg: #111111;
      --panel: #151515;
      --panel-2: #161616;
      --border: #1f1f1f;
      --fg: #e6e6e6;
      --muted: #b8b8b8;
      --accent: #8fff8f;
      --btn: #1c1c1c;
      --btn-hover: #222222;
      --btn-border: #2a2a2a;
      --btn-border-hover: #333333;
      --btn-active: #333333;
      --btn-active-border: #505050;
      --btn-disabled: #171717;
      --btn-disabled-border: #1f1f1f;
      --tab: #1a1a1a;
      --tab-active: #202020;
      --tab-border: #262626;
    }

    html, body {
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans,
        "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100%;
    }

    #game {
      width: min(980px, 96vw);
      margin: 18px auto 48px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 10px 12px;
    }

    #top {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-bottom: 12px;
    }

    #pointsRow {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }

    #pointsRow h1 {
      font-size: 1.2rem;
      margin: 0;
      font-weight: 700;
    }

    #rate {
      color: var(--accent);
      font-weight: 600;
      white-space: nowrap;
      font-size: 0.95rem;
    }

    #levelRow {
      margin-top: 6px;
      color: var(--muted);
      font-size: 0.95rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      background: var(--panel-2);
    }

    .control-button {
      padding: 5px 10px;
      background: var(--btn);
      color: var(--fg);
      border: 1px solid var(--btn-border);
      border-radius: 3px;
      cursor: pointer;
      transition: background-color .1s, border-color .1s, transform .02s;
      user-select: none;
      font-size: 0.95rem;
    }
    .control-button:hover { background: var(--btn-hover); border-color: var(--btn-border-hover); }
    .control-button.active { background: var(--btn-active); border-color: var(--btn-active-border); box-shadow: inset 0 0 0 1px #5c5c5c; }
    .control-button:active { transform: translateY(1px); }

    /* Tabs */
    #tabs {
      display: flex;
      gap: 6px;
      margin: 10px 0;
      align-items: center;
    }
    .tab {
      background: var(--tab);
      border: 1px solid var(--tab-border);
      color: var(--fg);
      padding: 6px 10px;
      border-radius: 3px;
      cursor: pointer;
      user-select: none;
      font-size: 0.95rem;
    }
    .tab.active {
      background: var(--tab-active);
      border-color: var(--btn-active-border);
      box-shadow: inset 0 0 0 1px #4a4a4a;
    }
    .tab.disabled {
      opacity: 0.5;
      cursor: default;
    }
    .tab.settings {
      margin-left: auto;
    }

    #content { margin-top: 8px; }

    /* Lists */
    .list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .layer {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px 12px;
      align-items: center;
    }
    .layer .head { display: flex; align-items: baseline; gap: 10px; }
    .layer .name { font-size: 1.05rem; font-weight: 700; }
    .layer .amount { font-size: 0.98rem; color: var(--fg); }
    .layer .hint { grid-column: 1 / -1; color: var(--muted); font-size: 0.92rem; }

    .buy {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
    }
    .buy .cost { color: var(--muted); font-size: 0.95rem; }
    .buy .button {
      padding: 9px 12px;
      background: var(--btn);
      color: var(--fg);
      border: 1px solid var(--btn-border);
      border-radius: 3px;
      cursor: default;
      transition: background-color .1s, border-color .1s, transform .02s;
      user-select: none;
      min-width: 240px;
      text-align: center;
      font-size: 0.95rem;
    }
    .buy .button:hover:not([disabled]) { background: var(--btn-hover); border-color: var(--btn-border-hover); }
    .buy .button:active:not([disabled]) { transform: translateY(1px); }
    .buy .button[disabled] {
      background: var(--btn-disabled);
      border-color: var(--btn-disabled-border);
      color: #777;
      cursor: default;
    }

    @media (min-width: 720px) {
      #top { grid-template-columns: 1fr auto; }
      .layer { grid-template-columns: 1fr auto; }
    }

    #metaTab .card, #prestigeTab .card, #settingsTab .card { background: var(--panel-2); }
  </style>
</head>
<body>
  <div id="game">
    <div id="top">
      <div id="pointsCard" class="card">
        <div id="pointsRow">
          <h1>Points: <span id="points">0</span></h1>
          <div id="rate">(+1/s)</div>
        </div>
        <div id="levelRow">
          <div>Level: <span id="level">0.00</span></div>
          <div id="metaPointsRow">Meta Points: <span id="metaPoints">0</span></div>
        </div>
      </div>

      <div id="controls" class="card" aria-label="Buy amount controls">
        <span>Buy amount:</span>
        <button class="control-button active" data-buy="1">1x</button>
        <button class="control-button" data-buy="10">10x</button>
        <button class="control-button" data-buy="100">100x</button>
        <button class="control-button" data-buy="half">50% Max</button>
        <button class="control-button" data-buy="max">Max</button>
      </div>
    </div>

    <div id="tabs">
      <div class="tab active" data-tab="layers">Layers</div>
      <div class="tab disabled" data-tab="prestige">Prestige</div>
      <div class="tab disabled" data-tab="meta">Meta-Layers</div>
      <div class="tab settings" data-tab="settings">Settings</div>
    </div>

    <div id="content">
      <div id="layersTab">
        <div id="layers" class="list"></div>
      </div>

      <div id="prestigeTab" style="display:none;">
        <div class="card" id="prestigeCard">
          <h3 style="margin:0 0 8px;">Prestige</h3>
          <div id="prestigeInfo" style="color:var(--muted); margin-bottom:8px;"></div>
          <button id="prestigeBtn" class="control-button" style="margin-top:6px;">Prestige</button>
          <div id="prestigeNote" style="color:var(--muted); margin-top:8px; font-size:0.92rem;">
            Warning: prestige resets layers and points
          </div>
        </div>
      </div>

      <div id="metaTab" style="display:none;">
        <div id="metaLayers" class="list"></div>
      </div>

      <div id="settingsTab" style="display:none;">
        <div class="card">
          <h3 style="margin:0 0 8px;">Settings</h3>
          <div style="color:var(--muted); margin-bottom:6px;">Point production multiplier (testing):</div>
          <div id="ppsMulControls">
            <button class="control-button pps active" data-pmul="1">1x</button>
            <button class="control-button pps" data-pmul="1e3">1k</button>
            <button class="control-button pps" data-pmul="1e6">1m</button>
            <button class="control-button pps" data-pmul="1e9">1b</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      // ===== Config =====
      const NAMES = [
        'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta',
        'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho',
        'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'
      ];

      const SUFFIX = [
        'k','m','b','t','qa','qi','sx','sp','oc','no',
        'dc','ud','dd','td','qad','qid','sxd','spd','ocd','nod',
        'vg','uvg','dvg','tvg','qavg','qivg','sxvg','spvg','ocvg','novg',
        'ct','uct','dct','tct','qact','qict','sxc','spc','occ','noc'
      ];

      // ===== EN (log10 magnitude) =====
      class EN {
        constructor(e) { this.e = e; } // value = 10^e; zero => -Infinity
        static zero() { return new EN(-Infinity); }
        static one() { return new EN(0); }
        static fromNumber(n) { return (n > 0) ? new EN(Math.log10(n)) : EN.zero(); }
        static fromInt(n) { return (n > 0) ? new EN(Math.log10(n)) : EN.zero(); }
        static pow10(x) { return new EN(x); }
        clone(){ return new EN(this.e); }
        isZero(){ return this.e === -Infinity; }
        static add(a,b){
          if (a.isZero()) return b.clone();
          if (b.isZero()) return a.clone();
          const mx = Math.max(a.e,b.e), mn = Math.min(a.e,b.e);
          const diff = mx - mn;
          if (diff > 12) return new EN(mx);
          const addLog = Math.log10(1 + Math.pow(10, -diff));
          return new EN(mx + addLog);
        }
        static sub(a,b){
          if (b.isZero()) return a.clone();
          if (a.isZero()) return EN.zero();
          if (a.e <= b.e) return EN.zero();
          const diff = a.e - b.e;
          if (diff > 12) return new EN(a.e);
          const subLog = Math.log10(1 - Math.pow(10, -diff));
          return new EN(a.e + subLog);
        }
        static mul(a,b){ return (a.isZero()||b.isZero()) ? EN.zero() : new EN(a.e + b.e); }
        static div(a,b){
          if (a.isZero()) return EN.zero();
          if (b.isZero()) return new EN(Infinity);
          return new EN(a.e - b.e);
        }
        static pow(a,p){
          if (a.isZero()) return EN.zero();
          if (p===0) return EN.one();
          return new EN(a.e * p);
        }
        toNumberSafe(){
          if (!isFinite(this.e) || Math.abs(this.e) > 15) return null;
          return Math.pow(10, this.e);
        }
      }

      function floorEN(x){
        if (x.isZero()) return EN.zero();
        const e = x.e;
        if (e < 0) return EN.zero();
        if (e < 15) return EN.fromNumber(Math.floor(Math.pow(10, e)));
        return x.clone();
      }
      function intGte(aEN, bEN) {
        const fa = floorEN(aEN).e;
        const fb = floorEN(bEN).e;
        return fa >= fb;
      }
      function subIntAmount(amountEN, costEN) {
        const costIntEN = floorEN(costEN);
        return EN.sub(amountEN, costIntEN);
      }

      function formatEN(x) {
        x = floorEN(x);
        if (x.isZero()) return '0';
        const e = x.e;
        if (e < 3 && e > -3) {
          const n = x.toNumberSafe();
          if (n !== null) return Math.floor(n).toLocaleString();
        }
        if (e >= 3 && e < 100) {
          const tier = Math.floor(e / 3);
          const suf = SUFFIX[tier - 1];
          if (suf) {
            const mant = Math.pow(10, e - tier * 3);
            let s = mant.toPrecision(3);
            s = s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
            return s + suf;
          }
        }
        const expo = Math.floor(e);
        const frac = e - expo;
        let m = Math.pow(10, frac).toPrecision(3).replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
        return m + 'e' + expo;
      }
      function formatENFloat(x) {
        if (x.isZero()) return '0.00';
        const e = x.e;
        if (e < 6 && e > -6) {
          const n = Math.pow(10, e);
          return Number(n.toPrecision(3)).toString();
        }
        const expo = Math.floor(e);
        const frac = e - expo;
        let m = Math.pow(10, frac).toPrecision(3).replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
        return m + 'e' + expo;
      }
      function formatLevelEN(x) {
        if (x.isZero()) return '0.00';
        const e = x.e;
        if (e < 6 && e > -6) {
          const n = x.toNumberSafe();
          if (n !== null) return Number(n.toPrecision(3)).toString();
        }
        const expo = Math.floor(e);
        const frac = e - expo;
        let m = Math.pow(10, frac).toPrecision(3).replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
        return m + 'e' + expo;
      }

      // ===== Game state =====
      const game = {
        points: EN.zero(),
        metaPoints: EN.zero(),
        layers: NAMES.map(n => ({ name: n, amount: EN.zero(), bought: EN.zero(), ever: EN.zero() })),
        metaLayers: NAMES.map(n => ({ name: n + '+', amount: EN.zero(), bought: EN.zero() })),
        buyMode: 1, // 1|10|100|'half'|'max'
        residualPoints: 0,
        ppsMulEN: EN.one(),
        unlockedTabs: { prestige: false, meta: false },
        unlockedNormal: Array(NAMES.length).fill(false),
        unlockedMeta: Array(NAMES.length).fill(false),
      };
      game.unlockedNormal[0] = true;

      // ===== DOM refs =====
      const pointsEl = document.getElementById('points');
      const rateEl = document.getElementById('rate');
      const levelEl = document.getElementById('level');
      const metaPointsEl = document.getElementById('metaPoints');
      const layersEl = document.getElementById('layers');
      const metaLayersEl = document.getElementById('metaLayers');
      const controlsEl = document.getElementById('controls');
      const tabsEl = document.getElementById('tabs');
      const layersTabEl = document.getElementById('layersTab');
      const prestigeTabEl = document.getElementById('prestigeTab');
      const metaTabEl = document.getElementById('metaTab');
      const settingsTabEl = document.getElementById('settingsTab');
      const prestigeInfoEl = document.getElementById('prestigeInfo');
      const prestigeBtn = document.getElementById('prestigeBtn');

      // ===== Mechanics: Costs depend on bought counts (NOT amounts) =====
      function normalExp(i) { const n = i + 1; return Math.sqrt(n + 2); }
      function metaExp(i)   { const n = i + 1; return Math.cbrt(n + 3); }

      function singleCostNormalAt(i, boughtEN) {
        // cost = (b + 2)^sqrt(n+2)
        const baseEN = EN.add(floorEN(boughtEN), EN.fromInt(2));
        return EN.pow(baseEN, normalExp(i));
      }
      function singleCostNormalOffset(i, boughtEN, jOffset) {
        const baseEN = EN.add(floorEN(boughtEN), EN.fromInt(2 + jOffset));
        return EN.pow(baseEN, normalExp(i));
      }
      function singleCostMetaAt(i, boughtEN) {
        // cost = (k + 2)^cbrt(n+3)
        const baseEN = EN.add(floorEN(boughtEN), EN.fromInt(2));
        return EN.pow(baseEN, metaExp(i));
      }
      function singleCostMetaOffset(i, boughtEN, jOffset) {
        const baseEN = EN.add(floorEN(boughtEN), EN.fromInt(2 + jOffset));
        return EN.pow(baseEN, metaExp(i));
      }

      // Exact sums for small n (<=100)
      function exactTotalCostNormal(i, n, boughtEN) {
        if (n <= 0) return EN.zero();
        let s = EN.zero();
        for (let j = 0; j < n; j++) s = EN.add(s, singleCostNormalOffset(i, boughtEN, j));
        return s;
      }
      function exactTotalCostMeta(i, n, boughtEN) {
        if (n <= 0) return EN.zero();
        let s = EN.zero();
        for (let j = 0; j < n; j++) s = EN.add(s, singleCostMetaOffset(i, boughtEN, j));
        return s;
      }

      // Integral approximations for large n
      function integralCostNormal(i, n, boughtEN) {
        if (n <= 0) return EN.zero();
        const p = normalExp(i), q = p + 1;
        const x0EN = EN.add(floorEN(boughtEN), EN.fromInt(2));
        const x1EN = EN.add(floorEN(boughtEN), EN.fromInt(2 + n));
        const term = EN.sub(EN.pow(x1EN, q), EN.pow(x0EN, q));
        return EN.div(term, EN.fromNumber(q));
      }
      function integralCostMeta(i, n, boughtEN) {
        if (n <= 0) return EN.zero();
        const p = metaExp(i), q = p + 1;
        const x0EN = EN.add(floorEN(boughtEN), EN.fromInt(2));
        const x1EN = EN.add(floorEN(boughtEN), EN.fromInt(2 + n));
        const term = EN.sub(EN.pow(x1EN, q), EN.pow(x0EN, q));
        return EN.div(term, EN.fromNumber(q));
      }
      function comboCostNormal(i, n, boughtEN) {
        if (n <= 0) return EN.zero();
        if (n <= 100) return exactTotalCostNormal(i, n, boughtEN);
        const base = n - 100;
        const lower = integralCostNormal(i, base, boughtEN);
        const tail = exactTotalCostNormal(i, 100, EN.add(boughtEN, EN.fromInt(base)));
        return EN.add(lower, tail);
      }
      function comboCostMeta(i, n, boughtEN) {
        if (n <= 0) return EN.zero();
        if (n <= 100) return exactTotalCostMeta(i, n, boughtEN);
        const base = n - 100;
        const lower = integralCostMeta(i, base, boughtEN);
        const tail = exactTotalCostMeta(i, 100, EN.add(boughtEN, EN.fromInt(base)));
        return EN.add(lower, tail);
      }

      // Invert integral upper bound to estimate n from budget
      function estimateNFromBudgetNormal(i, budgetEN, boughtEN) {
        const p = normalExp(i), q = p + 1;
        const x0EN = EN.add(floorEN(boughtEN), EN.fromInt(2));
        const rhs = EN.add(EN.mul(budgetEN, EN.fromNumber(q)), EN.pow(x0EN, q));
        const x1EN = EN.pow(rhs, 1 / q);
        const x0 = x0EN.toNumberSafe();
        const x1 = x1EN.toNumberSafe();
        if (x0 === null || x1 === null) return 0;
        const n = Math.floor(x1 - x0);
        return Number.isFinite(n) && n > 0 ? n : 0;
      }
      function estimateNFromBudgetMeta(i, budgetEN, boughtEN) {
        const p = metaExp(i), q = p + 1;
        const x0EN = EN.add(floorEN(boughtEN), EN.fromInt(2));
        const rhs = EN.add(EN.mul(budgetEN, EN.fromNumber(q)), EN.pow(x0EN, q));
        const x1EN = EN.pow(rhs, 1 / q);
        const x0 = x0EN.toNumberSafe();
        const x1 = x1EN.toNumberSafe();
        if (x0 === null || x1 === null) return 0;
        const n = Math.floor(x1 - x0);
        return Number.isFinite(n) && n > 0 ? n : 0;
      }

      // Currency for purchasing
      function currencyEN_forNormal(i) { return (i === 0) ? floorEN(game.points) : floorEN(game.layers[i-1].amount); }
      function currencyEN_forMeta(i)   { return (i === 0) ? floorEN(game.metaPoints) : floorEN(game.metaLayers[i-1].amount); }

      // Multipliers (per-buy gain)
      function normalPurchaseMultEN(i) {
        const nextNorm = game.layers[i+1] ? floorEN(game.layers[i+1].amount) : EN.zero();
        const metaSame = game.metaLayers[i] ? floorEN(game.metaLayers[i].amount) : EN.zero();
        return EN.mul(EN.add(nextNorm, EN.one()), EN.add(metaSame, EN.one()));
      }
      function metaPurchaseMultEN(i) {
        const nextMeta = game.metaLayers[i+1] ? floorEN(game.metaLayers[i+1].amount) : EN.zero();
        return EN.add(nextMeta, EN.one());
      }
      function displayNormalMultEN(i) {
        const nextNorm = game.layers[i+1] ? floorEN(game.layers[i+1].amount) : EN.zero();
        const metaSame = game.metaLayers[i] ? floorEN(game.metaLayers[i].amount) : EN.zero();
        return EN.mul(EN.add(nextNorm, EN.one()), EN.add(metaSame, EN.one()));
      }
      function displayMetaMultEN(i) {
        const nextMeta = game.metaLayers[i+1] ? floorEN(game.metaLayers[i+1].amount) : EN.zero();
        return EN.add(nextMeta, EN.one());
      }

      // PPS
      function pointsPerSecondEN() {
        const alphaInt = floorEN(game.layers[0].amount);
        const metaAlphaInt = floorEN(game.metaLayers[0].amount);
        const base = EN.mul(EN.add(alphaInt, EN.one()), EN.add(metaAlphaInt, EN.one()));
        return EN.mul(base, game.ppsMulEN);
      }

      // Level (3 sig figs when shown)
      const LN10 = Math.log(10);
      function computeLevelEN() {
        let total = EN.zero();
        for (let i = 0; i < game.layers.length; i++) {
          const amtInt = floorEN(game.layers[i].amount);
          if (amtInt.isZero()) continue;
          const n = i + 1;
          const factor = Math.pow(n, Math.pow(n, 1/3));
          const lnPart = (amtInt.e + 1) * LN10;
          if (!(lnPart > 0) || !isFinite(factor)) continue;
          total = EN.add(total, EN.pow10(Math.log10(factor) + Math.log10(lnPart)));
        }
        return total;
      }

      // Prestige reward: integer meta points = floor( ln( Î _i (amount_i + 1) ) )
      function computeMetaRewardEN() {
        let sLog10 = 0;
        for (let i = 0; i < game.layers.length; i++) {
          const term = EN.add(floorEN(game.layers[i].amount), EN.one()); // amount_i + 1
          if (!term.isZero()) sLog10 += term.e; // log10(product) = sum e
        }
        const lnProd = sLog10 * LN10;           // ln(product)
        if (!(lnProd > 0)) return EN.zero();
        return EN.fromNumber(lnProd);           // represent reward in EN (10^log10(lnProd))
      }

      // Unlocks
      function checkUnlockTabs() {
        if (!game.unlockedTabs.prestige || !game.unlockedTabs.meta) {
          const deltaOwned = !floorEN(game.layers[3].ever).isZero() || !floorEN(game.layers[3].amount).isZero();
          if (deltaOwned) {
            game.unlockedTabs.prestige = true;
            game.unlockedTabs.meta = true;
            game.unlockedMeta[0] = true;
            saveToCookieThrottled();
          }
        }
      }

      // ===== Build UI =====
      function layerNameColor(i) {
        const start = 0, end = 330;
        const hue = start + (end - start) * (i / (NAMES.length - 1));
        return `hsl(${hue.toFixed(1)}deg, 80%, 60%)`;
      }
      function metaGradient(i) {
        // Prominent static gradient, larger hue separation
        const total = NAMES.length - 1;
        const base = i / total;
        const hueStart = 0 + base * 300;
        const hueEnd = Math.min(hueStart + 80, 360);
        return `linear-gradient(90deg, hsl(${hueStart.toFixed(1)}deg, 92%, 60%), hsl(${hueEnd.toFixed(1)}deg, 92%, 60%))`;
      }

      function buildNormalUI() {
        layersEl.innerHTML = '';
        NAMES.forEach((name, i) => {
          const card = document.createElement('div');
          card.className = 'card layer';
          card.id = `layer-${i}`;

          const head = document.createElement('div');
          head.className = 'head';
          const title = document.createElement('div');
          title.className = 'name';
          title.style.color = layerNameColor(i);
          title.textContent = name;
          const amt = document.createElement('div');
          amt.className = 'amount';
          amt.id = `amount-${i}`;
          head.appendChild(title);
          head.appendChild(amt);

          const hint = document.createElement('div');
          hint.className = 'hint';
          hint.id = `hint-${i}`;
          card.appendChild(head);
          card.appendChild(hint);

          const buyRow = document.createElement('div');
          buyRow.className = 'buy';
          const cost = document.createElement('div');
          cost.className = 'cost';
          cost.id = `cost-${i}`;
          const btn = document.createElement('button');
          btn.className = 'button';
          btn.id = `buy-${i}`;
          btn.textContent = `Buy`;
          btn.addEventListener('click', () => buyNormal(i));
          buyRow.appendChild(cost);
          buyRow.appendChild(btn);
          card.appendChild(buyRow);

          layersEl.appendChild(card);
        });
      }

      function buildMetaUI() {
        metaLayersEl.innerHTML = '';
        NAMES.forEach((name, i) => {
          const card = document.createElement('div');
          card.className = 'card layer';
          card.id = `mlayer-${i}`;

          const head = document.createElement('div');
          head.className = 'head';
          const title = document.createElement('div');
          title.className = 'name';
          title.style.backgroundImage = metaGradient(i);
          title.style.webkitBackgroundClip = 'text';
          title.style.backgroundClip = 'text';
          title.style.color = 'transparent';
          title.style.webkitTextFillColor = 'transparent';
          title.textContent = name + '+';
          const amt = document.createElement('div');
          amt.className = 'amount';
          amt.id = `mamount-${i}`;
          head.appendChild(title);
          head.appendChild(amt);

          const hint = document.createElement('div');
          hint.className = 'hint';
          hint.id = `mhint-${i}`;
          card.appendChild(head);
          card.appendChild(hint);

          const buyRow = document.createElement('div');
          buyRow.className = 'buy';
          const cost = document.createElement('div');
          cost.className = 'cost';
          cost.id = `mcost-${i}`;
          const btn = document.createElement('button');
          btn.className = 'button';
          btn.id = `mbuy-${i}`;
          btn.textContent = `Buy`;
          btn.addEventListener('click', () => buyMeta(i));
          buyRow.appendChild(cost);
          buyRow.appendChild(btn);

          card.appendChild(buyRow);
          metaLayersEl.appendChild(card);
        });
      }

      // ===== Visibility =====
      function applyNormalVisibility() {
        for (let i = 0; i < game.layers.length; i++) {
          const el = document.getElementById(`layer-${i}`);
          if (el) el.style.display = game.unlockedNormal[i] ? '' : 'none';
        }
      }
      function applyMetaVisibility() {
        for (let i = 0; i < game.metaLayers.length; i++) {
          const el = document.getElementById(`mlayer-${i}`);
          if (el) el.style.display = game.unlockedMeta[i] ? '' : 'none';
        }
      }

      // ===== Display (top) =====
      function updateTopRow() {
        pointsEl.textContent = formatEN(game.points);
        rateEl.textContent = `(+${formatEN(pointsPerSecondEN())}/s)`;
        // meta points are integers now
        metaPointsEl.textContent = formatEN(game.metaPoints);
      }

      // ===== Normal rows =====
      function updateNormalRow(i, superficial = true) {
        const L = game.layers[i];
        const amtEl = document.getElementById(`amount-${i}`);
        const costEl = document.getElementById(`cost-${i}`);
        const btnEl = document.getElementById(`buy-${i}`);
        const hintEl = document.getElementById(`hint-${i}`);

        amtEl.textContent = `Amount: ${formatEN(L.amount)}`;

        const prevDisplay = (i === 0) ? 'points' : NAMES[i-1];
        hintEl.textContent = `Multiplies ${prevDisplay}`;

        const cur = currencyEN_forNormal(i);
        const boughtEN = floorEN(L.bought); // costs depend on bought count
        const dispMult = displayNormalMultEN(i);
        const prevName = (i === 0) ? 'points' : NAMES[i-1].toLowerCase();

        if (game.buyMode === 1 || game.buyMode === 10 || game.buyMode === 100) {
          const desired = game.buyMode;
          const totalCost = comboCostNormal(i, desired, boughtEN); // exact if <=100
          const canAffordOne = intGte(cur, floorEN(singleCostNormalAt(i, boughtEN)));
          costEl.textContent = `Cost: ${formatEN(totalCost)} ${prevName}`;
          const productEN = EN.mul(EN.fromInt(desired), dispMult);
          btnEl.textContent = `Buy ${formatEN(EN.fromInt(desired))}x${formatEN(dispMult)}=${formatEN(productEN)}`;
          btnEl.disabled = !(canAffordOne && intGte(cur, floorEN(totalCost)));
        } else {
          // half/max with upper-integral estimate and exact tail
          const budget = (game.buyMode === 'half') ? floorEN(EN.mul(cur, EN.fromNumber(0.5))) : cur;
          const costOne = floorEN(singleCostNormalAt(i, boughtEN));
          const canAffordOne = intGte(budget, costOne);

          let nEst = estimateNFromBudgetNormal(i, budget, boughtEN);
          if (nEst < 1 && canAffordOne) nEst = 1;

          // Adjust nEst down if the upper integral overshoots budget
          let spendInt = (nEst > 0) ? floorEN(integralCostNormal(i, nEst, boughtEN)) : EN.zero();
          let guard = 0;
          while (nEst > 0 && !intGte(budget, spendInt) && guard < 8) {
            nEst = Math.floor(nEst * 0.8);
            spendInt = floorEN(integralCostNormal(i, nEst, boughtEN));
            guard++;
          }
          // Exact top-off up to 100 for precise final n
          let extra = 0;
          while (extra < 100) {
            const nextCostInt = floorEN(singleCostNormalOffset(i, boughtEN, nEst + extra));
            const trial = EN.add(spendInt, nextCostInt);
            if (intGte(budget, trial)) { spendInt = trial; extra++; } else break;
          }
          const totalN = nEst + extra;

          // Display rules: if cannot afford any, show cost to buy 1
          const shownCost = (totalN <= 0) ? costOne
                          : (totalN <= 100 ? floorEN(exactTotalCostNormal(i, totalN, boughtEN))
                                           : floorEN(EN.add(integralCostNormal(i, totalN - 100, boughtEN),
                                                            exactTotalCostNormal(i, 100, EN.add(boughtEN, EN.fromInt(totalN - 100))))));
          const shownCountEN = EN.fromInt(Math.max(1, totalN));
          costEl.textContent = `Cost: ${formatEN(shownCost)} ${prevName}`;
          const productEN = EN.mul(shownCountEN, dispMult);
          btnEl.textContent = `Buy ${formatEN(shownCountEN)}x${formatEN(dispMult)}=${formatEN(productEN)}`;
          btnEl.disabled = !canAffordOne;
        }
      }

      function updateNormalList(superficial = true) {
        applyNormalVisibility();
        for (let i = 0; i < game.layers.length; i++) {
          if (game.unlockedNormal[i]) updateNormalRow(i, superficial);
        }
      }

      // ===== Meta rows =====
      function updateMetaRow(i, superficial = true) {
        const ML = game.metaLayers[i];
        const amtEl = document.getElementById(`mamount-${i}`);
        const costEl = document.getElementById(`mcost-${i}`);
        const btnEl = document.getElementById(`mbuy-${i}`);
        const hintEl = document.getElementById(`mhint-${i}`);

        amtEl.textContent = `Amount: ${formatEN(ML.amount)}`;

        const normalName = NAMES[i];
        if (i === 0) {
          hintEl.textContent = `Multiplies ${normalName}`;
        } else {
          const prevMetaName = NAMES[i-1] + '+';
          hintEl.textContent = `Multiplies ${prevMetaName} and ${normalName}`;
        }

        const cur = currencyEN_forMeta(i);
        const boughtEN = floorEN(ML.bought); // costs depend on meta bought count
        const dispMult = displayMetaMultEN(i);
        const prevName = (i === 0) ? 'meta points' : (NAMES[i-1]+'+').toLowerCase();

        if (game.buyMode === 1 || game.buyMode === 10 || game.buyMode === 100) {
          const desired = game.buyMode;
          const totalCost = comboCostMeta(i, desired, boughtEN);
          const canAffordOne = intGte(cur, floorEN(singleCostMetaAt(i, boughtEN)));
          costEl.textContent = `Cost: ${formatEN(totalCost)} ${prevName}`;
          const productEN = EN.mul(EN.fromInt(desired), dispMult);
          btnEl.textContent = `Buy ${formatEN(EN.fromInt(desired))}x${formatEN(dispMult)}=${formatEN(productEN)}`;
          btnEl.disabled = !(canAffordOne && intGte(cur, floorEN(totalCost)));
        } else {
          const budget = (game.buyMode === 'half') ? floorEN(EN.mul(cur, EN.fromNumber(0.5))) : cur;
          const costOne = floorEN(singleCostMetaAt(i, boughtEN));
          const canAffordOne = intGte(budget, costOne);

          let nEst = estimateNFromBudgetMeta(i, budget, boughtEN);
          if (nEst < 1 && canAffordOne) nEst = 1;

          let spendInt = (nEst > 0) ? floorEN(integralCostMeta(i, nEst, boughtEN)) : EN.zero();
          let guard = 0;
          while (nEst > 0 && !intGte(budget, spendInt) && guard < 8) {
            nEst = Math.floor(nEst * 0.8);
            spendInt = floorEN(integralCostMeta(i, nEst, boughtEN));
            guard++;
          }
          let extra = 0;
          while (extra < 100) {
            const nextCostInt = floorEN(singleCostMetaOffset(i, boughtEN, nEst + extra));
            const trial = EN.add(spendInt, nextCostInt);
            if (intGte(budget, trial)) { spendInt = trial; extra++; } else break;
          }
          const totalN = nEst + extra;

          const shownCost = (totalN <= 0) ? costOne
                          : (totalN <= 100 ? floorEN(exactTotalCostMeta(i, totalN, boughtEN))
                                           : floorEN(EN.add(integralCostMeta(i, totalN - 100, boughtEN),
                                                            exactTotalCostMeta(i, 100, EN.add(boughtEN, EN.fromInt(totalN - 100))))));
          const shownCountEN = EN.fromInt(Math.max(1, totalN));
          costEl.textContent = `Cost: ${formatEN(shownCost)} ${prevName}`;
          const productEN = EN.mul(shownCountEN, dispMult);
          btnEl.textContent = `Buy ${formatEN(shownCountEN)}x${formatEN(dispMult)}=${formatEN(productEN)}`;
          btnEl.disabled = !canAffordOne;
        }
      }

      function updateMetaList(superficial = true) {
        applyMetaVisibility();
        for (let i = 0; i < game.metaLayers.length; i++) {
          if (game.unlockedMeta[i]) updateMetaRow(i, superficial);
        }
      }

      // ===== Purchasing =====
      function afterNormalPurchaseUnlocks(i) {
        game.unlockedNormal[i] = true;
        if (i === 0 && !game.unlockedNormal[1]) game.unlockedNormal[1] = true;
        if (i === 3 && !game.unlockedNormal[2]) game.unlockedNormal[2] = true;
        if (i + 1 < game.unlockedNormal.length) game.unlockedNormal[i + 1] = true;
      }
      function afterMetaPurchaseUnlocks(i) {
        game.unlockedMeta[i] = true;
        if (i + 1 < game.unlockedMeta.length) game.unlockedMeta[i + 1] = true;
      }

      function buyNormal(i) {
        const L = game.layers[i];
        const cur = currencyEN_forNormal(i);
        const boughtEN = floorEN(L.bought);
        const mult = normalPurchaseMultEN(i);

        if (game.buyMode === 1 || game.buyMode === 10 || game.buyMode === 100) {
          const desired = game.buyMode;
          const totalCost = comboCostNormal(i, desired, boughtEN);
          if (!intGte(cur, floorEN(totalCost))) return;
          performNormalPurchase(i, desired, totalCost, mult);
          return;
        }

        // buy max / half with integral + tail
        const totalBudget = (game.buyMode === 'half') ? floorEN(EN.mul(cur, EN.fromNumber(0.5))) : cur;
        let n = estimateNFromBudgetNormal(i, totalBudget, boughtEN);
        if (n < 0) n = 0;
        let spendInt = floorEN(integralCostNormal(i, n, boughtEN));
        let guard = 0;
        while (n > 0 && !intGte(totalBudget, spendInt) && guard < 8) {
          n = Math.floor(n * 0.8);
          spendInt = floorEN(integralCostNormal(i, n, boughtEN));
          guard++;
        }
        let extra = 0;
        while (extra < 100) {
          const nextCostInt = floorEN(singleCostNormalOffset(i, boughtEN, n + extra));
          const trial = EN.add(spendInt, nextCostInt);
          if (intGte(totalBudget, trial)) { spendInt = trial; extra++; } else break;
        }
        const totalN = n + extra;
        if (totalN <= 0) return;

        performNormalPurchase(i, totalN, spendInt, mult);
      }

      function performNormalPurchase(i, countInt, totalCostEN, mult) {
        // Deduct from currency
        if (i === 0) {
          if (!intGte(game.points, floorEN(totalCostEN))) return;
          game.points = subIntAmount(game.points, totalCostEN);
        } else {
          const prev = game.layers[i-1];
          if (!intGte(prev.amount, floorEN(totalCostEN))) return;
          prev.amount = subIntAmount(prev.amount, totalCostEN);
        }

        // Apply gains and bought increments
        const L = game.layers[i];
        const gain = EN.mul(EN.fromInt(countInt), mult);
        L.bought = EN.add(L.bought, EN.fromInt(countInt));
        L.amount = EN.add(L.amount, gain);
        L.ever = EN.add(L.ever, gain);

        afterNormalPurchaseUnlocks(i);
        checkUnlockTabs();

        updateTopRow();
        updateNormalList(false);
        if (game.unlockedTabs.meta) updateMetaList(false);
        applyNormalVisibility();
        applyMetaVisibility();
        levelEl.textContent = formatLevelEN(computeLevelEN());
        saveToCookieThrottled();
      }

      function buyMeta(i) {
        const ML = game.metaLayers[i];
        const cur = currencyEN_forMeta(i);
        const boughtEN = floorEN(ML.bought);
        const mult = metaPurchaseMultEN(i);

        if (game.buyMode === 1 || game.buyMode === 10 || game.buyMode === 100) {
          const desired = game.buyMode;
          const totalCost = comboCostMeta(i, desired, boughtEN);
          if (!intGte(cur, floorEN(totalCost))) return;
          performMetaPurchase(i, desired, totalCost, mult);
          return;
        }

        const totalBudget = (game.buyMode === 'half') ? floorEN(EN.mul(cur, EN.fromNumber(0.5))) : cur;
        let n = estimateNFromBudgetMeta(i, totalBudget, boughtEN);
        if (n < 0) n = 0;
        let spendInt = floorEN(integralCostMeta(i, n, boughtEN));
        let guard = 0;
        while (n > 0 && !intGte(totalBudget, spendInt) && guard < 8) {
          n = Math.floor(n * 0.8);
          spendInt = floorEN(integralCostMeta(i, n, boughtEN));
          guard++;
        }
        let extra = 0;
        while (extra < 100) {
          const nextCostInt = floorEN(singleCostMetaOffset(i, boughtEN, n + extra));
          const trial = EN.add(spendInt, nextCostInt);
          if (intGte(totalBudget, trial)) { spendInt = trial; extra++; } else break;
        }
        const totalN = n + extra;
        if (totalN <= 0) return;

        performMetaPurchase(i, totalN, spendInt, mult);
      }

      function performMetaPurchase(i, countInt, totalCostEN, mult) {
        if (i === 0) {
          if (!intGte(game.metaPoints, floorEN(totalCostEN))) return;
          game.metaPoints = subIntAmount(game.metaPoints, totalCostEN);
        } else {
          const prev = game.metaLayers[i-1];
          if (!intGte(prev.amount, floorEN(totalCostEN))) return;
          prev.amount = subIntAmount(prev.amount, totalCostEN);
        }

        const ML = game.metaLayers[i];
        const gain = EN.mul(EN.fromInt(countInt), mult);
        ML.bought = EN.add(ML.bought, EN.fromInt(countInt));
        ML.amount = EN.add(ML.amount, gain);

        afterMetaPurchaseUnlocks(i);

        updateTopRow();
        updateMetaList(false);
        if (game.unlockedNormal[i]) updateNormalRow(i, false);
        levelEl.textContent = formatLevelEN(computeLevelEN());
        saveToCookieThrottled();
      }

      // ===== Prestige =====
      function updatePrestigeUI() {
        const rewardEN = computeMetaRewardEN();
        const rewardIntEN = floorEN(rewardEN); // integer meta points
        prestigeInfoEl.innerHTML = `Gain on prestige: ${formatEN(rewardIntEN)} meta points`;
        prestigeBtn.disabled = rewardIntEN.isZero();
      }
      function doPrestige() {
        const rewardEN = floorEN(computeMetaRewardEN());
        if (rewardEN.isZero()) return;
        game.metaPoints = EN.add(game.metaPoints, rewardEN);

        // Reset normals
        game.points = EN.zero();
        game.residualPoints = 0;
        for (let i = 0; i < game.layers.length; i++) {
          game.layers[i].amount = EN.zero();
          game.layers[i].bought = EN.zero();
          game.layers[i].ever = EN.zero();
        }

        updateTopRow();
        updateNormalList(false);
        updateMetaList(false);
        updatePrestigeUI();
        applyNormalVisibility();
        applyMetaVisibility();
        levelEl.textContent = formatLevelEN(computeLevelEN());
        saveToCookieThrottled();
      }
      prestigeBtn.addEventListener('click', doPrestige);

      // ===== Tabs/Unlocks =====
      let currentTab = 'layers';
      function refreshTabLocks() {
        checkUnlockTabs();
        const prestigeTab = [...tabsEl.children].find(t => t.getAttribute('data-tab') === 'prestige');
        const metaTab = [...tabsEl.children].find(t => t.getAttribute('data-tab') === 'meta');

        if (game.unlockedTabs.prestige) prestigeTab.classList.remove('disabled'); else prestigeTab.classList.add('disabled');
        if (game.unlockedTabs.meta) metaTab.classList.remove('disabled'); else metaTab.classList.add('disabled');

        if ((currentTab === 'prestige' && !game.unlockedTabs.prestige) ||
            (currentTab === 'meta' && !game.unlockedTabs.meta)) {
          switchTab('layers');
        }
      }
      function switchTab(which) {
        currentTab = which;
        tabsEl.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        const tabBtn = [...tabsEl.children].find(t => t.getAttribute('data-tab') === which);
        if (tabBtn) tabBtn.classList.add('active');

        layersTabEl.style.display = (which === 'layers') ? '' : 'none';
        prestigeTabEl.style.display = (which === 'prestige') ? '' : 'none';
        metaTabEl.style.display = (which === 'meta') ? '' : 'none';
        settingsTabEl.style.display = (which === 'settings') ? '' : 'none';

        if (which === 'layers') updateNormalList(true);
        if (which === 'prestige') updatePrestigeUI();
        if (which === 'meta') updateMetaList(true);
      }
      tabsEl.addEventListener('click', (e) => {
        const t = e.target.closest('.tab');
        if (!t) return;
        const dest = t.getAttribute('data-tab');
        if ((dest === 'prestige' && t.classList.contains('disabled')) ||
            (dest === 'meta' && t.classList.contains('disabled'))) return;
        switchTab(dest);
      });

      // ===== Controls (buy amount) =====
      controlsEl.addEventListener('click', (e) => {
        const btn = e.target.closest('.control-button');
        if (!btn) return;
        const mode = btn.getAttribute('data-buy');
        game.buyMode = (mode === 'max' || mode === 'half') ? mode : parseInt(mode, 10);
        controlsEl.querySelectorAll('.control-button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        if (currentTab === 'layers') updateNormalList(true);
        if (currentTab === 'meta') updateMetaList(true);
        updatePrestigeUI();
        saveToCookieThrottled();
      });

      // ===== Settings: PPS multiplier =====
      document.getElementById('ppsMulControls').addEventListener('click', (e) => {
        const btn = e.target.closest('.pps');
        if (!btn) return;
        const mul = btn.getAttribute('data-pmul');
        let val = 1;
        if (mul === '1e3') val = 1e3;
        else if (mul === '1e6') val = 1e6;
        else if (mul === '1e9') val = 1e9;
        else val = 1;
        game.ppsMulEN = EN.fromNumber(val);
        document.querySelectorAll('#ppsMulControls .pps').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        saveToCookieThrottled();
      });

      // ===== Cookies =====
      const COOKIE_NAME = 'cascade_incremental_save_v6';
      const COOKIE_DAYS = 365;
      function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = "expires=" + d.toUTCString();
        document.cookie = name + "=" + encodeURIComponent(value) + ";" + expires + ";path=/;SameSite=Lax";
      }
      function getCookie(name) {
        const cname = name + "=";
        const ca = document.cookie.split(';');
        for (let c of ca) {
          c = c.trim();
          if (c.indexOf(cname) === 0) return decodeURIComponent(c.substring(cname.length));
        }
        return null;
      }
      function boolArrayToString(arr) { return arr.map(b => (b ? '1' : '0')).join(''); }
      function stringToBoolArray(s, len) {
        const out = Array(len).fill(false);
        if (typeof s !== 'string') return out;
        for (let i = 0; i < Math.min(len, s.length); i++) out[i] = s[i] === '1';
        return out;
      }
      function saveToCookie() {
        const payload = {
          p: game.points.e,
          mp: game.metaPoints.e,
          m: game.buyMode,
          pm: game.ppsMulEN.e,
          ut: [game.unlockedTabs.prestige ? 1 : 0, game.unlockedTabs.meta ? 1 : 0],
          un: boolArrayToString(game.unlockedNormal),
          um: boolArrayToString(game.unlockedMeta),
          l: game.layers.map(L => [L.amount.e, L.bought.e, L.ever.e]),
          ml: game.metaLayers.map(L => [L.amount.e, L.bought.e]),
        };
        try { setCookie(COOKIE_NAME, JSON.stringify(payload), COOKIE_DAYS); } catch {}
      }
      let saveThrottle = 0;
      function saveToCookieThrottled() {
        const now = performance.now();
        if (now - saveThrottle > 3000) { saveThrottle = now; saveToCookie(); }
      }
      function loadFromCookie() {
        const raw = getCookie(COOKIE_NAME);
        if (!raw) return;
        try {
          const data = JSON.parse(raw);
          if (typeof data.p === 'number') game.points = EN.pow10(data.p);
          if (typeof data.mp === 'number') game.metaPoints = EN.pow10(data.mp);
          if (data.m === 'max' || data.m === 'half' || data.m === 1 || data.m === 10 || data.m === 100) game.buyMode = data.m;
          if (typeof data.pm === 'number') game.ppsMulEN = EN.pow10(data.pm);
          if (Array.isArray(data.ut) && data.ut.length === 2) {
            game.unlockedTabs.prestige = !!data.ut[0];
            game.unlockedTabs.meta = !!data.ut[1];
          }
          if (typeof data.un === 'string') game.unlockedNormal = stringToBoolArray(data.un, NAMES.length);
          if (typeof data.um === 'string') game.unlockedMeta = stringToBoolArray(data.um, NAMES.length);
          if (Array.isArray(data.l) && data.l.length === game.layers.length) {
            for (let i = 0; i < game.layers.length; i++) {
              const [amtE, boughtE, everE] = data.l[i] || [];
              if (typeof amtE === 'number') game.layers[i].amount = EN.pow10(amtE);
              if (typeof boughtE === 'number') game.layers[i].bought = EN.pow10(boughtE);
              if (typeof everE === 'number') game.layers[i].ever = EN.pow10(everE);
            }
          }
          if (Array.isArray(data.ml) && data.ml.length === game.metaLayers.length) {
            for (let i = 0; i < game.metaLayers.length; i++) {
              const [amtE, boughtE] = data.ml[i] || [];
              if (typeof amtE === 'number') game.metaLayers[i].amount = EN.pow10(amtE);
              if (typeof boughtE === 'number') game.metaLayers[i].bought = EN.pow10(boughtE);
            }
          }
          game.unlockedNormal[0] = true;

          controlsEl.querySelectorAll('.control-button').forEach(b => {
            const mode = b.getAttribute('data-buy');
            const m = (mode === 'max' || mode === 'half') ? mode : parseInt(mode,10);
            if (m === game.buyMode) b.classList.add('active'); else b.classList.remove('active');
          });
          document.querySelectorAll('#ppsMulControls .pps').forEach(b => {
            const val = b.getAttribute('data-pmul');
            const e = (val === '1') ? 0 : (val === '1e3' ? 3 : (val === '1e6' ? 6 : (val === '1e9' ? 9 : 0)));
            if (Math.abs(game.ppsMulEN.e - e) < 1e-9) b.classList.add('active'); else b.classList.remove('active');
          });
        } catch {}
      }
      window.addEventListener('beforeunload', saveToCookie);

      // ===== Loops =====
      let last = performance.now();
      function frame(now) {
        const dt = Math.max(0, Math.min(0.2, (now - last) / 1000));
        last = now;

        const pps = pointsPerSecondEN();
        const gainEN = EN.mul(pps, EN.fromNumber(dt));
        if (gainEN.e < 0) {
          const g = gainEN.toNumberSafe() ?? 0;
          game.residualPoints += g;
          if (game.residualPoints >= 1) {
            const k = Math.floor(game.residualPoints);
            game.residualPoints -= k;
            game.points = EN.add(game.points, EN.fromInt(k));
          }
        } else {
          const whole = floorEN(gainEN);
          if (!whole.isZero()) game.points = EN.add(game.points, whole);
        }

        updateTopRow();
        refreshTabLocks();

        requestAnimationFrame(frame);
      }

      // Throttled UI
      setInterval(() => {
        if (currentTab === 'layers') updateNormalList(true);
        else if (currentTab === 'meta') updateMetaList(true);
      }, 250);
      setInterval(() => {
        levelEl.textContent = formatLevelEN(computeLevelEN());
        if (currentTab === 'prestige') updatePrestigeUI();
      }, 500);

      // Init
      function init() {
        buildNormalUI();
        buildMetaUI();
        loadFromCookie();
        updateTopRow();
        applyNormalVisibility();
        applyMetaVisibility();
        updateNormalList(true);
        updateMetaList(true);
        updatePrestigeUI();
        refreshTabLocks();
        requestAnimationFrame(frame);
      }
      init();
    })();
  </script>
</body>
</html>
